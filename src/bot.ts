import { Telegraf, Markup, Context } from 'telegraf';
import { sequelize } from './db';
require('dotenv').config()
import LocalSession = require("telegraf-session-local")
import { getMainMenu, getEventsInline, getEventInfo, getPeopleCountInline, getSlotsInlineWithCounts, getAdminMenu, getParticipantsList, getParticipantsInlineBack, getAdminBookingsListWithButtons } from './bot-menu';
import { Event } from './models/event.model';
import { TimeSlot } from './models/timeslot.model';
import { Booking } from './models/booking.model';
import { User } from './models/user.model';
import { UpdateType } from 'telegraf/typings/telegram-types';
import * as fs from 'fs';
import * as path from 'path';
import { Sequelize } from 'sequelize-typescript';
import { SubSlot } from './models/subslot.model';
import { getMyBookingsMenu, getBookingDetailMenu } from './my-bookings-menu';
import { BookingMember } from './models/bookingmember.model';
import { WhereOptions } from 'sequelize';
import { CallbackQuery, Update } from 'telegraf/typings/core/types/typegram';

const bot = new Telegraf(process.env.BOT_TOKEN!);

// –ü–æ–¥–∫–ª—é—á–∞–µ–º session
bot.use((new LocalSession({ database: 'session_db.json' })).middleware());

const allowed_updates:UpdateType[] = ["message", "callback_query", "chat_member"];

// –†–∞—Å—à–∏—Ä—è–µ–º —Ç–∏–ø–∏–∑–∞—Ü–∏—é –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –¥–ª—è session
declare module 'telegraf/typings/context' {
  interface Context {
    session?: {
      slotId?: number;
      eventId?: number;
      subslotId?: number;
      free?: number;
      admin?: boolean;
      friends?: string[];
      addingFriend?: boolean;
      lastMessageId?:number
    };
  }
}

const ADMIN_IDS = (process.env.ADMIN_IDS || '').split(',').map(id => id.trim()).filter(Boolean).map(Number);
function isAdmin(userId: number) {
  return ADMIN_IDS.includes(userId);
}

async function importEventsIfNeeded(sequelize: Sequelize) {
  if (process.env.IMPORT_EVENTS === '1') {
    const sqlPath = path.join(__dirname, '../sql/events_import.sql');
    if (fs.existsSync(sqlPath)) {
      const sql = fs.readFileSync(sqlPath, 'utf-8');
      try {
        await sequelize.query(sql);
        console.log('–ò–º–ø–æ—Ä—Ç –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–π –∏–∑ events_import.sql –≤—ã–ø–æ–ª–Ω–µ–Ω!');
      } catch (e) {
        console.error('–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–π:', e);
      }
    } else {
      console.warn('–§–∞–π–ª events_import.sql –Ω–µ –Ω–∞–π–¥–µ–Ω!');
    }
  }
}

(async () => {
  try {
    await sequelize.authenticate();
    await sequelize.sync();
    await importEventsIfNeeded(sequelize);
    console.log('–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∞ –∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–∞!');
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö:', error);
    process.exit(1);
  }

  if (process.env.NODE_ENV === "production") {
    bot.catch(console.error);

    const secretPath = `/clothes/telegraf/${bot.secretPathComponent()}`;

    console.log(secretPath);

    await bot.launch({
      webhook: {
        domain: process.env.SERVER_URI,
        hookPath: secretPath,
        host: '127.0.0.1',
        port: +(process.env.PORT ?? 3030),
      },
      //allowedUpdates: allowed_updates,
      dropPendingUpdates: true,
    });

    console.log(await bot.telegram.getWebhookInfo());
  } else {
    await bot.launch({
      allowedUpdates: allowed_updates,
      dropPendingUpdates: true,
    });
  }

process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));
})();





// –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ
bot.use(async (ctx, next) => {
  if (ctx.from) {
    const [user] = await User.findOrCreate({
      where: { telegram_id: ctx.from.id },
      defaults: { telegram_id: ctx.from.id, name: ctx.from.first_name },
    });
    ctx.state.user = user;
  }
  return next();
});

// –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é —Å –∞–¥–º–∏–Ω-–∫–Ω–æ–ø–∫–æ–π
bot.start((ctx) => {
  const welcome = `
*–î–æ—Ä–æ–≥–æ–π —É—á–∞—Å—Ç–Ω–∏–∫ —Ç—É—Ä—Å–ª—ë—Ç–∞!* üëã

–ó–¥–µ—Å—å –º–æ–∂–Ω–æ _–∑–∞–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —Å–≤–æ–±–æ–¥–Ω—ã–µ –ª–æ–∫–∞—Ü–∏–∏_, –∫–æ—Ç–æ—Ä—ã–µ —Ä–∞–±–æ—Ç–∞—é—Ç —Å *15:30 –¥–æ 18:30*.
–ú–æ–∂–Ω–æ –∑–∞–ø–∏—Å–∞—Ç—å —Å–µ–±—è, –∫–æ–ª–ª–µ–≥—É –∏–ª–∏ –ª—é–±–∏–º–æ–≥–æ —Ä–µ–±—ë–Ω–∫–∞.

–ù–µ –∑–∞–±—ã–≤–∞–π –æ *–º–∞—Å—Ç–µ—Ä-–∫–ª–∞—Å—Å–∞—Ö* –≤ —à–∞—Ç—Ä–µ ‚Äî —Ç—É–¥–∞ –º–æ–∂–Ω–æ –ø–æ–ø–∞—Å—Ç—å –≤ —Å–≤–æ–±–æ–¥–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ –∏ —Å–¥–µ–ª–∞—Ç—å —Å–≤–æ—é —É–Ω–∏–∫–∞–ª—å–Ω—É—é –≤–µ—â—å:
‚Ä¢ —Å–æ—Ç–≤–æ—Ä–∏—Ç—å –±—Ä–∞—Å–ª–µ—Ç –∏–∑ –±—É—Å–∏–Ω
‚Ä¢ —Ä–∞—Å–ø–∏—Å–∞—Ç—å –∑–Ω–∞—á–æ–∫
‚Ä¢ —Ä–∞—Å–ø–∏—Å–∞—Ç—å —Ñ—Ä–∏—Å–±–∏

_–•–æ—Ä–æ—à–µ–≥–æ —Ç–µ–±–µ –æ—Ç–¥—ã—Ö–∞!_

*–ü–æ–º–Ω–∏:* –µ—Å–ª–∏ —Ç—ã —Ö–æ—á–µ—à—å –æ—Ç–º–µ–Ω–∏—Ç—å –∑–∞–ø–∏—Å—å ‚Äî —ç—Ç–æ –ª–µ–≥–∫–æ —Å–¥–µ–ª–∞—Ç—å –∑–¥–µ—Å—å –∂–µ.
`;
  if (ctx.from && isAdmin(ctx.from.id)) {
    return ctx.reply('–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, –∞–¥–º–∏–Ω!', getAdminMenu());
  }
  return ctx.reply(welcome, { parse_mode: 'Markdown', ...getMainMenu() });
});


async function sendAdminMenu(ctx:Context,isEdit?:boolean){

const reply = (isEdit? ctx.editMessageText: ctx.reply).bind(ctx)
  if (!ctx.from || !isAdmin(ctx.from.id)) return;
  const events = await Event.findAll({ order: [['id', 'ASC']] });
  if (!events.length) return reply('–ù–µ—Ç –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–π.');
  await reply('–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞:', getEventsInline(events,true));
  ctx.session = { admin: true };
}

bot.hears('üëë –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å', async (ctx) => {
    sendAdminMenu(ctx)
});

// –í—ã–±–æ—Ä –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è –≤ –∞–¥–º–∏–Ω-—Ä–µ–∂–∏–º–µ
bot.action(/event_admin_(\d+)/, async (ctx, next) => {
  await safeAnswerCbQuery(ctx);

  if (ctx.session &&  ctx.from && isAdmin(ctx.from.id)) {

    const eventId = Number(ctx.match[1]);
    const event = await Event.findByPk(eventId);
    const slots = await TimeSlot.findAll({ where: { event_id: eventId } });
    if (!slots.length) {
      try {
        await ctx.editMessageText('–ù–µ—Ç —Å–ª–æ—Ç–æ–≤ –¥–ª—è —ç—Ç–æ–≥–æ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è.');
      } catch (e: any) {
        if (e.description?.includes('message is not modified')) {
          //await safeAnswerCbQuery(ctx, '–£–∂–µ –≤—ã–±—Ä–∞–Ω–æ.');
        } else {
          throw e;
        }
      }
      return;
    }
    try {
      await ctx.editMessageText(`*${event?.title || '–ú–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ'}*\n\n–í—ã–±–µ—Ä–∏—Ç–µ —Å–ª–æ—Ç:`, {
        parse_mode: 'Markdown',
        ...getSlotsInlineWithCounts(slots,true, {}, [], 0),
      });
    } catch (e: any) {
      if (e.description?.includes('message is not modified')) {
        //await safeAnswerCbQuery(ctx, '–£–∂–µ –≤—ã–±—Ä–∞–Ω–æ.');
      } else {
        throw e;
      }
    }
    ctx.session.eventId = eventId;
    return;
  }
  return next();
});

async function sendSlotAdminMenu(ctx: Context,slotId: number) {
    const slot = await TimeSlot.findByPk(slotId);
    const event = slot ? await Event.findByPk(slot.event_id) : null;
    const bookings = await Booking.findAll({
      where: { timeslot_id: slotId },
      include: [
        { model: User, as: 'user' },
        { model: SubSlot, as: 'subslot' },
        { model: BookingMember, as: 'members' },
      ],
    });
    // –î–ª—è –∞–¥–º–∏–Ω–∫–∏: —Å–ø–∏—Å–æ–∫ –∑–∞–ø–∏—Å–µ–π —Å —É—á–∞—Å—Ç–Ω–∏–∫–∞–º–∏
    const bookingList = bookings.map((b) => ({
      id: b.id,
      members: b.members?.map(m => m.name) || [],
      subslot_title: b.subslot ? b.subslot.title : undefined,
    }));
    const {text, keyboard} = getAdminBookingsListWithButtons(bookingList);
    const used = bookings.reduce((acc, b) => acc + (b.members?.length || 0), 0);
    const free = event ? event.capacity - used : 0;
    const slotInfo = slot && event
      ? `*${event.title}*\n–í—Ä–µ–º—è: ${formatTime(slot.start_time)}‚Äì${formatTime(slot.end_time)}\n–°–≤–æ–±–æ–¥–Ω–æ –º–µ—Å—Ç: ${free}`
      : '';
    await ctx.editMessageText(`${slotInfo}\n\n${text}`, {
      parse_mode: 'Markdown',
      ...(keyboard ? { ...keyboard } : getParticipantsInlineBack()),
    });
    ctx.session.slotId = slotId;
    return;
}

// –í—ã–±–æ—Ä —Å–ª–æ—Ç–∞ –≤ –∞–¥–º–∏–Ω-—Ä–µ–∂–∏–º–µ
bot.action(/slot_admin_(\d+)/, async (ctx, next) => {
  await safeAnswerCbQuery(ctx);

  if (ctx.session && ctx.from && isAdmin(ctx.from.id)) {
    const slotId = Number((ctx as any).match[1]);
   return await sendSlotAdminMenu(ctx,slotId)
  }
  return next();
});

// –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
bot.hears('üóì –ú–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è –∏ –∑–∞–ø–∏—Å—å', async (ctx) => {
  const events = await Event.findAll({ order: [['id', 'ASC']] });
  if (!events.length) return ctx.reply('–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–π.');
  if (ctx.callbackQuery) {
    await ctx.editMessageText('–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ:', getEventsInline(events));
  } else {
    await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ:', getEventsInline(events));
  }
});

// –°–ø–∏—Å–æ–∫ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–π (inline)
bot.action(/event_(\d+)/, async (ctx) => {
  const eventId = Number(ctx.match[1]);
  const event = await Event.findByPk(eventId);
  if (!event) return safeAnswerCbQuery(ctx, '–ú–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ');
  await safeAnswerCbQuery(ctx);

  const slots = await TimeSlot.findAll({ where: { event_id: event.id } });
  // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è –≤—Å–µ—Ö —Å–ª–æ—Ç–æ–≤ —ç—Ç–æ–≥–æ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è
  const allBookings = await Booking.findAll({ where: { event_id: event.id } });
  // –î–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–ª–æ—Ç–∞ —Å—á–∏—Ç–∞–µ–º bookingIds –∏ BookingMember.count
  const slotCounts: Record<number, number> = {};
  for (const slot of slots) {
    const bookings = allBookings.filter(b => b.timeslot_id === slot.id);
    const bookingIds = bookings.map(b => b.id);
    slotCounts[slot.id] = bookingIds.length > 0 ? await BookingMember.count({ where: { booking_id: bookingIds } }) : 0;
  }
  // used ‚Äî –≤—Å–µ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –ø–æ –≤—Å–µ–º —Å–ª–æ—Ç–∞–º
  const used = Object.values(slotCounts).reduce((a, b) => a + b, 0);
  const free = event.capacity - used;
  // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∑–∞–ø–∏—Å–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π
  let disabledSlotIds: number[] = [];
  if (ctx.state.user) {
    const userBookings = await Booking.findAll({
      where: { user_id: ctx.state.user.id },
      include: [{ model: TimeSlot, as: 'timeslot' }],
    });
    disabledSlotIds = 
    slots
      .filter((slot) =>
        userBookings.some((b) => {
          const s = b.timeslot;
          if (!s) return false;
         // if (slot.id===s.id) return false;
          const newStart = slot.start_time.getTime();
          const newEnd = slot.end_time.getTime();
          const existStart = s.start_time.getTime();
          const existEnd = s.end_time.getTime();
          return newStart < existEnd && newEnd > existStart;
        })
      )
      .map((slot) => slot.id);
  }

  await ctx.editMessageText(getEventInfo(event, free, slots), {
    parse_mode: 'Markdown',
    ...getSlotsInlineWithCounts(slots, false, slotCounts, disabledSlotIds, event.capacity),
  });
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –Ω–∞ –Ω–µ–∞–∫—Ç–∏–≤–Ω—É—é –∫–Ω–æ–ø–∫—É
bot.action('disabled_slot', async (ctx) => {
  await safeAnswerCbQuery(ctx, '–í—ã —É–∂–µ –∑–∞–ø–∏—Å–∞–Ω—ã –Ω–∞ —ç—Ç–æ –≤—Ä–µ–º—è.');
});

// –ú–µ–Ω—é –¥–ª—è –∑–∞–ø–∏—Å–∏ —Å –¥—Ä—É–∑—å—è–º–∏
function getBookingMenu(free: number, friends: string[], eventId: number) {
  let text = `–°–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤:\n`;
  if (friends.length === 0) {
    text += '_–ü–æ–∫–∞ –Ω–∏–∫—Ç–æ –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω_';
  } else {
    friends.forEach((name, i) => {
      text += `\n${i + 1}. ${name}`;
    });
  }
  text += `\n\n–°–≤–æ–±–æ–¥–Ω–æ –µ—â–µ –º–µ—Å—Ç: ${free}`;
  text += `\n\n–î–æ–±–∞–≤—å—Ç–µ —Å–µ–±—è –∏/–∏–ª–∏ –¥—Ä—É–∑–µ–π. –ö–∞–∂–¥—ã–π —É—á–∞—Å—Ç–Ω–∏–∫ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω –ø–æ –æ—Ç–¥–µ–ª—å–Ω–æ—Å—Ç–∏.`;
  text += `\n\n–ö–æ–≥–¥–∞ –≤—Å–µ —É—á–∞—Å—Ç–Ω–∏–∫–∏ –¥–æ–±–∞–≤–ª–µ–Ω—ã, –Ω–∞–∂–º–∏—Ç–µ ‚úÖ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.`;

  const buttons = [
    ...(friends.length > 0 && free >= 0 ? [[Markup.button.callback('‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –∑–∞–ø–∏—Å—å', 'confirm_booking')]] : []),
    ...(free > 0 ? [[Markup.button.callback('üë® –î–æ–±–∞–≤–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞', 'add_friend')]] : []),
    [Markup.button.callback('‚¨ÖÔ∏è –ù–∞–∑–∞–¥', `event_${eventId}`)],
  ];

  return {
    text,
    keyboard: Markup.inlineKeyboard(buttons),
  };
}

async function getFreePlacesCount(event:Event,slotId:number,capacity: number,subslotId?: number){
    // –°—á–∏—Ç–∞–µ–º —Å–≤–æ–±–æ–¥–Ω—ã–µ –º–µ—Å—Ç–∞ –ø–æ —Å–ª–æ—Ç—É
  const whereClause: WhereOptions = { event_id: event.id, timeslot_id: slotId }
    if (subslotId!==undefined) whereClause.subslot_id = subslotId
console.log(234,subslotId)
    const bookings = await Booking.findAll({ where: whereClause });
    const bookingIds = bookings.map(b => b.id);
    const taken = bookingIds.length > 0 ? await BookingMember.count({ where: { booking_id: bookingIds } }) : 0;
    const free = capacity - taken;

    return free
}

// –í—ã–±–æ—Ä —Å–ª–æ—Ç–∞ (inline)
bot.action(/slot_(\d+)/, async (ctx) => {
  const slotId = Number(ctx.match[1]);
  const slot = await TimeSlot.findByPk(slotId);
  if (!slot) return ctx.answerCbQuery('–°–ª–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω');
  const event = await Event.findByPk(slot.event_id, { include: [SubSlot] });
  if (!event) return ctx.answerCbQuery('–ú–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ');
  if (!event.subslots || event.subslots.length === 0) {
    // –ù–µ—Ç SubSlot ‚Äî —Å—Ä–∞–∑—É –º–µ–Ω—é –∑–∞–ø–∏—Å–∏
    // –°—á–∏—Ç–∞–µ–º —Å–≤–æ–±–æ–¥–Ω—ã–µ –º–µ—Å—Ç–∞ –ø–æ —Å–ª–æ—Ç—É
    const free = await getFreePlacesCount(event,slot.id,event.capacity);
    if (free <= 0) return ctx.answerCbQuery('–ù–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö –º–µ—Å—Ç –Ω–∞ —ç—Ç–æ—Ç —Å–ª–æ—Ç');
    await safeAnswerCbQuery(ctx);

    ctx.session = { slotId, eventId: event.id, free, friends: [] };
    const slotInfo = `*${event.title}*\n${event.description ? event.description + '\n' : ''}–í—Ä–µ–º—è: ${formatTime(slot.start_time)}‚Äì${formatTime(slot.end_time)}`;
    const menu = getBookingMenu(free, [],event.id);
    await ctx.editMessageText(`${slotInfo}\n\n${menu.text}`, {
      parse_mode: 'Markdown',
      ...menu.keyboard,
    });
    return;
  }
  await safeAnswerCbQuery(ctx);

  // –ï—Å–ª–∏ –µ—Å—Ç—å SubSlot ‚Äî –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—ã–±–æ—Ä SubSlot
  const buttons = [];
  for (const subslot of event.subslots) {
    const bookings = await Booking.findAll({ where: { timeslot_id: slot.id, subslot_id: subslot.id } });
    const bookingIds = bookings.map(b => b.id);
    const used = bookingIds.length > 0 ? await BookingMember.count({ where: { booking_id: bookingIds } }) : 0;
    const free = subslot.capacity - used;
    buttons.push([Markup.button.callback(`${subslot.title} (—Å–≤–æ–±–æ–¥–Ω–æ: ${free})`, `s2lot_${slot.id}_${subslot.id}`)]);
  }
  buttons.push([Markup.button.callback('‚¨ÖÔ∏è –ù–∞–∑–∞–¥', `event_${event.id}`)]);
  await ctx.editMessageText(
    `*${event.title}*\n${event.description ? event.description + '\n' : ''}–í—Ä–µ–º—è: ${formatTime(slot.start_time)}‚Äì${formatTime(slot.end_time)}\n\n–í—ã–±–µ—Ä–∏—Ç–µ ${
      event.id === 8 ? '–∫–æ–º–∞–Ω–¥—É' : event.id === 1 ? '–ª–æ–¥–∫—É' : '–∫–∞—Ç–∞–º–∞—Ä–∞–Ω'}:`,
    {
      parse_mode: 'Markdown',
      ...Markup.inlineKeyboard(buttons),
    }
  );
  ctx.session = { slotId, eventId: event.id };
});

// –î–æ–±–∞–≤–∏—Ç—å –¥—Ä—É–≥–∞
bot.action('add_friend', async (ctx) => {
  const session = ctx.session || {};
  // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ —Å—á–∏—Ç–∞–µ–º —Å–≤–æ–±–æ–¥–Ω—ã–µ –º–µ—Å—Ç–∞
  let free = 0;
  if (session.subslotId) {
    const slot = await TimeSlot.findByPk(session.slotId);
    const subslot = await SubSlot.findByPk(session.subslotId);
    if (slot && subslot) {
      const bookings = await Booking.findAll({ where: { timeslot_id: slot.id, subslot_id: subslot.id } });
      const bookingIds = bookings.map(b => b.id);
      const taken = bookingIds.length > 0 ? await BookingMember.count({ where: { booking_id: bookingIds } }) : 0;
      free = subslot.capacity - taken - (session.friends?.length || 0);
    }
  } else if (session.slotId) {
    const slot = await TimeSlot.findByPk(session.slotId);
    if (slot) {
      const event = await Event.findByPk(slot.event_id);
      if (event) {
        const bookings = await Booking.findAll({ where: { timeslot_id: slot.id } });
        const bookingIds = bookings.map(b => b.id);
        const taken = bookingIds.length > 0 ? await BookingMember.count({ where: { booking_id: bookingIds } }) : 0;
        free = event.capacity - taken - (session.friends?.length || 0);
      }
    }
  }
  if (free <= 0) {
    return ctx.answerCbQuery('–ë–æ–ª—å—à–µ –¥–æ–±–∞–≤–∏—Ç—å –Ω–µ–ª—å–∑—è!');
  }
  await safeAnswerCbQuery(ctx);
  ctx.session.addingFriend = true;
  let sentMessage;
  if (ctx.callbackQuery && ctx.callbackQuery.message) {
    try {
      sentMessage = await ctx.editMessageText('–í–≤–µ–¥–∏—Ç–µ –∏–º—è –∏ —Ñ–∞–º–∏–ª–∏—é —É—á–∞—Å—Ç–Ω–∏–∫–∞:', {
        ...Markup.inlineKeyboard([
          [Markup.button.callback('‚¨ÖÔ∏è –ù–∞–∑–∞–¥', `basket_back_${session.eventId}`)]
        ]),
      });
    } catch (e) {
      sentMessage = await ctx.reply('–í–≤–µ–¥–∏—Ç–µ –∏–º—è –∏ —Ñ–∞–º–∏–ª–∏—é —É—á–∞—Å—Ç–Ω–∏–∫–∞:');
    }
  } else {
    sentMessage = await ctx.reply('–í–≤–µ–¥–∏—Ç–µ –∏–º—è –∏ —Ñ–∞–º–∏–ª–∏—é —É—á–∞—Å—Ç–Ω–∏–∫–∞:');
  }
  ctx.session.lastMessageId = sentMessage.message_id;
});

// –ö–Ω–æ–ø–∫–∞ –Ω–∞–∑–∞–¥ –∫ –∫–æ—Ä–∑–∏–Ω–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
bot.action(/basket_back_(\d+)/, async (ctx) => {
  await safeAnswerCbQuery(ctx);
  await backToBasket(ctx, true);
});

async function backToBasket(ctx: any, isEdit?: boolean) {
  // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é —Å–Ω–æ–≤–∞
  const slot = await TimeSlot.findByPk(ctx.session.slotId);
  let event = null;
  let slotInfo = '';
  let menu;
  const friendsCount = ctx.session.friends?.length || 0;
  const reply = (isEdit ? ctx.editMessageText : ctx.reply).bind(ctx);

  if (ctx.session.subslotId) {
    const subslot = await SubSlot.findByPk(ctx.session.subslotId);
    event = slot && subslot ? await Event.findByPk(slot.event_id) : null;
    if (!slot || !event || !subslot) return reply('–û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –≤—ã–±—Ä–∞—Ç—å —Å–ª–æ—Ç –∑–∞–Ω–æ–≤–æ.');
    slotInfo = `*${event.title}*\n${event.description ? event.description + '\n' : ''}–í—Ä–µ–º—è: ${formatTime(slot.start_time)}‚Äì${formatTime(slot.end_time)}\n–ö–æ–º–∞–Ω–¥–∞/–ª–æ–¥–∫–∞: ${subslot.title}`;
    // –°—á–∏—Ç–∞–µ–º –∑–∞–Ω—è—Ç—ã–µ –º–µ—Å—Ç–∞ —Ç–æ–ª—å–∫–æ –≤ —ç—Ç–æ–º subslot+slot
    const free = (await getFreePlacesCount(event,slot.id, subslot.capacity,subslot.id)) - friendsCount;

    menu = getBookingMenu(free, ctx.session.friends, event.id);
  } else {
    event = slot ? await Event.findByPk(slot.event_id) : null;
    if (!slot || !event) return reply('–û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –≤—ã–±—Ä–∞—Ç—å —Å–ª–æ—Ç –∑–∞–Ω–æ–≤–æ.');
    slotInfo = `*${event.title}*\n${event.description ? event.description + '\n' : ''}–í—Ä–µ–º—è: ${formatTime(slot.start_time)}‚Äì${formatTime(slot.end_time)}`;
    // –°—á–∏—Ç–∞–µ–º –∑–∞–Ω—è—Ç—ã–µ –º–µ—Å—Ç–∞ —Ç–æ–ª—å–∫–æ –≤ —ç—Ç–æ–º —Å–ª–æ—Ç–µ
    const free = (await getFreePlacesCount(event,slot.id, event.capacity)) - friendsCount;

    menu = getBookingMenu(free, ctx.session.friends, event.id);
  }
  const sent = await reply(`${slotInfo}\n\n${menu.text}`, {
    parse_mode: 'Markdown',
    ...menu.keyboard,
  });
  if (!isEdit && ctx.message && ctx.message.message_id) {
    // –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –∏–º–µ–Ω–µ–º
    try { await ctx.deleteMessage(ctx.message.message_id); } catch {}
  }
}

bot.on('text', async (ctx, next) => {
  if (ctx.session && ctx.session.addingFriend) {
    const name = ctx.message.text.trim();
    if (!name) return ctx.reply('–ò–º—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –í–≤–µ–¥–∏—Ç–µ –∏–º—è –∏ —Ñ–∞–º–∏–ª–∏—é —É—á–∞—Å—Ç–Ω–∏–∫–∞:');
    ctx.session.friends = ctx.session.friends || [];
    // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ —Å—á–∏—Ç–∞–µ–º —Å–≤–æ–±–æ–¥–Ω—ã–µ –º–µ—Å—Ç–∞
    let free = 0;
    if (ctx.session.subslotId) {
      const slot = await TimeSlot.findByPk(ctx.session.slotId);
      const subslot = await SubSlot.findByPk(ctx.session.subslotId);
      if (slot && subslot) {
        const bookings = await Booking.findAll({ where: { timeslot_id: slot.id, subslot_id: subslot.id } });
        const bookingIds = bookings.map(b => b.id);
        const taken = bookingIds.length > 0 ? await BookingMember.count({ where: { booking_id: bookingIds } }) : 0;
        free = subslot.capacity - taken - (ctx.session.friends?.length || 0);
      }
    } else if (ctx.session.slotId) {
      const slot = await TimeSlot.findByPk(ctx.session.slotId);
      if (slot) {
        const event = await Event.findByPk(slot.event_id);
        if (event) {
          const bookings = await Booking.findAll({ where: { timeslot_id: slot.id } });
          const bookingIds = bookings.map(b => b.id);
          const taken = bookingIds.length > 0 ? await BookingMember.count({ where: { booking_id: bookingIds } }) : 0;
          free = event.capacity - taken - (ctx.session.friends?.length || 0);
        }
      }
    }
    if (free <= 0) {
      ctx.session.addingFriend = false;
      return ctx.reply('–ë–æ–ª—å—à–µ –¥–æ–±–∞–≤–∏—Ç—å –Ω–µ–ª—å–∑—è!');
    }
    ctx.session.friends.push(name);
    ctx.session.addingFriend = false;
    // –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ "–í–≤–µ–¥–∏—Ç–µ –∏–º—è –∏ —Ñ–∞–º–∏–ª–∏—é —É—á–∞—Å—Ç–Ω–∏–∫–∞:" –µ—Å–ª–∏ –æ–Ω–æ –±—ã–ª–æ
    if (ctx.message.reply_to_message && ctx.message.reply_to_message.message_id) {
      try {
        await ctx.telegram.deleteMessage(ctx.chat.id, ctx.message.reply_to_message.message_id);
      } catch {}
    }
    if (ctx.session.lastMessageId){
        await ctx.telegram.deleteMessage(ctx.chat.id, ctx.session.lastMessageId);
        delete ctx.session.lastMessageId
    }
    await backToBasket(ctx)
    return;
  }
  return next();
});

// –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –∑–∞–ø–∏—Å—å
bot.action('confirm_booking', async (ctx) => {
  await safeAnswerCbQuery(ctx);
  const session = ctx.session || {};
  if (!session.slotId || !session.eventId || !session.friends || session.friends.length === 0) {
    return ctx.reply('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Å–ª–æ—Ç –∏ –¥–æ–±–∞–≤—å—Ç–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.');
  }
  // –°–æ–∑–¥–∞—ë–º –±—Ä–æ–Ω—å
  const booking = await Booking.create({
    user_id: ctx.state.user.id,
    event_id: session.eventId,
    timeslot_id: session.slotId,
    subslot_id: session.subslotId || null,
  });
  // –î–æ–±–∞–≤–ª—è–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
  for (const name of session.friends) {
    await BookingMember.create({ booking_id: booking.id, name });
  }
  await ctx.editMessageText('–í—ã —É—Å–ø–µ—à–Ω–æ –∑–∞–ø–∏—Å–∞–Ω—ã!');
  ctx.session = {};
  if (ctx.from && isAdmin(ctx.from.id)) {
    return await ctx.reply('–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é', getAdminMenu());
  }
  await ctx.reply('–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é', getMainMenu());
});

// –ú–æ–∏ –∑–∞–ø–∏—Å–∏ —Å –º–µ–Ω—é –∏ –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π
bot.hears('‚ùå –ú–æ–∏ –∑–∞–ø–∏—Å–∏ / –û—Ç–º–µ–Ω–∏—Ç—å –∑–∞–ø–∏—Å—å', async (ctx) => {
  const bookings = await Booking.findAll({
    where: { user_id: ctx.state.user.id },
    include: [ { model: Event, as: 'event' }, { model: TimeSlot, as: 'timeslot' } ]
  });
  if (!bookings.length) return ctx.reply('–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π.');
  const { text, keyboard } = getMyBookingsMenu(bookings, 0);
  await ctx.reply(text, { parse_mode: 'Markdown', ...keyboard });
});

bot.action(/mybookings_page_(\d+)/, async (ctx) => {
  await safeAnswerCbQuery(ctx);
  const page = Number(ctx.match[1]);
  const bookings = await Booking.findAll({
    where: { user_id: ctx.state.user.id },
    include: [ { model: Event, as: 'event' }, { model: TimeSlot, as: 'timeslot' } ]
  });
  const { text, keyboard } = getMyBookingsMenu(bookings, page);
  await ctx.editMessageText(text, { parse_mode: 'Markdown', ...keyboard });
});

bot.action(/mybooking_(\d+)/, async (ctx) => {
  await safeAnswerCbQuery(ctx);
  const bookingId = Number(ctx.match[1]);
  const booking = await Booking.findByPk(bookingId, { include: [ { model: Event, as: 'event' }, { model: TimeSlot, as: 'timeslot' }, { model: BookingMember, as: 'members' } ] });
  if (!booking) return ctx.editMessageText('–ó–∞–ø–∏—Å—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.');
  const { text, keyboard } = getBookingDetailMenu(booking);
  await ctx.editMessageText(text, { parse_mode: 'Markdown', ...keyboard });
});

bot.action(/remove_member_(\d+)/, async (ctx) => {
  await safeAnswerCbQuery(ctx);
  const memberId = Number(ctx.match[1]);
  const member = await BookingMember.findByPk(memberId);
  if (!member) return ctx.editMessageText('–£—á–∞—Å—Ç–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.');
  const bookingId = member.booking_id;
  await member.destroy();
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –æ—Å—Ç–∞–ª–∏—Å—å –ª–∏ —É—á–∞—Å—Ç–Ω–∏–∫–∏
  const membersLeft = await BookingMember.count({ where: { booking_id: bookingId } });
  
  const query = ctx.callbackQuery?.['data']
  const isAdminLocal = query && query.startsWith('admin') && ctx.from && isAdmin(ctx.from.id)

  if (membersLeft === 0) {
    const booking = await Booking.findByPk(bookingId);
    if (!booking) return ctx.editMessageText('–ó–∞–ø–∏—Å—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.');
    await booking.destroy();
    await safeAnswerCbQuery(ctx, '–ó–∞–ø–∏—Å—å —É–¥–∞–ª–µ–Ω–∞.');

    
    if (isAdminLocal) {
      await sendSlotAdminMenu(ctx,booking.timeslot_id);
      return
   }

    const bookings = await Booking.findAll({
      where: { user_id: ctx.state.user.id },
      include: [ { model: Event, as: 'event' }, { model: TimeSlot, as: 'timeslot' } ]
    });
    const { text, keyboard } = getMyBookingsMenu(bookings, 0);
    return ctx.editMessageText(text, { parse_mode: 'Markdown', ...keyboard });
  } else {
    await safeAnswerCbQuery(ctx, '–£—á–∞—Å—Ç–Ω–∏–∫ —É–¥–∞–ª—ë–Ω.');

    if (isAdminLocal) {
      await sendAdminBookingMenu(ctx,bookingId)
      return
    }
    const booking = await Booking.findByPk(bookingId, { include: [ { model: Event, as: 'event' }, { model: TimeSlot, as: 'timeslot' }, { model: BookingMember, as: 'members' } ] });
    const { text, keyboard } = getBookingDetailMenu(booking!);
    return ctx.editMessageText(text, { parse_mode: 'Markdown', ...keyboard });
  }
});

bot.action(/delete_booking_(\d+)/, async (ctx) => {
  
  await safeAnswerCbQuery(ctx);
  const bookingId = Number(ctx.match[1]);
  const booking = await Booking.findByPk(bookingId);
  if (!booking) return ctx.editMessageText('–ó–∞–ø–∏—Å—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.');
  await booking.destroy();
  await safeAnswerCbQuery(ctx, '–ó–∞–ø–∏—Å—å —É–¥–∞–ª–µ–Ω–∞.');

  const query = ctx.callbackQuery?.['data']
  if (query && query.startsWith('admin') && ctx.session && ctx.from && isAdmin(ctx.from.id)) {
     await sendSlotAdminMenu(ctx,booking.timeslot_id);
     return
  }
  // –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ –º–µ–Ω—é –º–æ–∏—Ö –∑–∞–ø–∏—Å–µ–π

  const bookings = await Booking.findAll({
    where: { user_id: ctx.state.user.id },
    include: [ { model: Event, as: 'event' }, { model: TimeSlot, as: 'timeslot' } ]
  });
  const { text, keyboard } = getMyBookingsMenu(bookings, 0);
  await ctx.editMessageText(text, { parse_mode: 'Markdown', ...keyboard });
});

bot.action('back_to_mybookings', async (ctx) => {
  await safeAnswerCbQuery(ctx);
  const bookings = await Booking.findAll({
    where: { user_id: ctx.state.user.id },
    include: [ { model: Event, as: 'event' }, { model: TimeSlot, as: 'timeslot' } ]
  });
  const { text, keyboard } = getMyBookingsMenu(bookings, 0);
  await ctx.editMessageText(text, { parse_mode: 'Markdown', ...keyboard });
});

bot.action('close_mybookings', async (ctx) => {
  await safeAnswerCbQuery(ctx);
  try { await ctx.deleteMessage(); } catch {}
});

// –ö–Ω–æ–ø–∫–∞ –Ω–∞–∑–∞–¥ –∫ —Å–ø–∏—Å–∫—É –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–π
bot.action('back_to_events', async (ctx) => {
  await safeAnswerCbQuery(ctx);

  const events = await Event.findAll({ order: [['id', 'ASC']] });
  try {
    await ctx.editMessageText('–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ:', getEventsInline(events));
  } catch (e: any) {
    if (e.description?.includes('message is not modified')) {
      //await safeAnswerCbQuery(ctx, '–£–∂–µ –≤—ã–±—Ä–∞–Ω–æ.');
    } else {
      throw e;
    }
  }
});

// –ö–Ω–æ–ø–∫–∞ –Ω–∞–∑–∞–¥ –∫ —Å–ø–∏—Å–∫—É –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–π
bot.action('admin_bta', async (ctx) => {
    await safeAnswerCbQuery(ctx);
    sendAdminMenu(ctx,true)
  });
  



// –ö–Ω–æ–ø–∫–∞ –Ω–∞–∑–∞–¥ –∫ —Å–ø–∏—Å–∫—É —Å–ª–æ—Ç–æ–≤ –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏
bot.action('admin_bts', async (ctx) => {

  const session = ctx.session || {};
  if (!session.eventId) return ctx.answerCbQuery('–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ');

  await safeAnswerCbQuery(ctx);

  const event = await Event.findByPk(session.eventId);
  const slots = await TimeSlot.findAll({ where: { event_id: session.eventId } });
  await ctx.editMessageText(`*${event?.title || '–ú–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ'}*\n\n–í—ã–±–µ—Ä–∏—Ç–µ —Å–ª–æ—Ç:`, {
    parse_mode: 'Markdown',
    ...getSlotsInlineWithCounts(slots,true, {}, [], 0),
  });
});

bot.action(/s2lot_(\d+)_(\d+)/, async (ctx) => {
    console.log('sslot')

  const slotId = Number(ctx.match[1]);
  const subslotId = Number(ctx.match[2]);
  const slot = await TimeSlot.findByPk(slotId);
  const subslot = await SubSlot.findByPk(subslotId);
  if (!slot || !subslot) return ctx.answerCbQuery('–û—à–∏–±–∫–∞ –≤—ã–±–æ—Ä–∞ –∫–æ–º–∞–Ω–¥—ã/–ª–æ–¥–∫–∏');
  const event = await Event.findByPk(subslot.event_id);
  if (!event) return ctx.answerCbQuery('–ú–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ');
  // –°—á–∏—Ç–∞–µ–º —Å–≤–æ–±–æ–¥–Ω—ã–µ –º–µ—Å—Ç–∞ –≤ —ç—Ç–æ–º subslot+slot
  const free = await getFreePlacesCount(event,slot.id,subslot.capacity,subslot.id);
  if (free <= 0) return ctx.answerCbQuery('–ù–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö –º–µ—Å—Ç –≤ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥–µ/–ª–æ–¥–∫–µ');
  
  ctx.session = { slotId, eventId: event.id, subslotId: subslot.id, free, friends: [] };
  const slotInfo = `*${event.title}*\n${event.description ? event.description + '\n' : ''}–í—Ä–µ–º—è: ${formatTime(slot.start_time)}‚Äì${formatTime(slot.end_time)}\n–ö–æ–º–∞–Ω–¥–∞/–ª–æ–¥–∫–∞: ${subslot.title}`;
  const menu = getBookingMenu(free, [],event.id);

  await safeAnswerCbQuery(ctx);

  await ctx.editMessageText(`${slotInfo}\n\n${menu.text}`, {
    parse_mode: 'Markdown',
    ...menu.keyboard,
  });
});

function formatTime(date: Date) {
  return date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit', timeZone: 'Etc/GMT0' });
}

// –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞ answerCbQuery
async function safeAnswerCbQuery(ctx: any, text?: string) {
  try {
    await ctx.answerCbQuery(text);
  } catch (e) {
    // ignore
  }
}


async function sendAdminBookingMenu(ctx: Context,bookingId: number){
  const booking = await Booking.findByPk(bookingId, { include: [ { model: Event, as: 'event' }, { model: TimeSlot, as: 'timeslot' }, { model: BookingMember, as: 'members' }, { model: SubSlot, as: 'subslot' } ] });
  if (!booking) return ctx.editMessageText('–ó–∞–ø–∏—Å—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.');
  const members = booking.members || [];
  // –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
  let membersText = '‚Äî';
  if (members.length > 0) {
    membersText = members.map((m, i) => `${i + 1}. ${m.name}`).join('\n');
  }
  // –ö–Ω–æ–ø–∫–∏ —É–¥–∞–ª–µ–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –≤ 2 —Ä—è–¥–∞
  const memberButtons = [];
  for (let i = 0; i < members.length; i += 2) {
    const row = [];
    row.push(Markup.button.callback(`–£–¥–∞–ª–∏—Ç—å: ${members[i].name}`, `admin_remove_member_${members[i].id}`));
    if (members[i + 1]) {
      row.push(Markup.button.callback(`–£–¥–∞–ª–∏—Ç—å: ${members[i + 1].name}`, `admin_remove_member_${members[i + 1].id}`));
    }
    memberButtons.push(row);
  }
  memberButtons.push([Markup.button.callback('‚ùå –£–¥–∞–ª–∏—Ç—å –∑–∞–ø–∏—Å—å', `admin_delete_booking_${booking.id}`)]);
  memberButtons.push([Markup.button.callback('‚¨ÖÔ∏è –ù–∞–∑–∞–¥', `slot_admin_${booking.timeslot_id}`)]);
  const text = `*${booking.event?.title}*\n–í—Ä–µ–º—è: ${formatTime(booking.timeslot?.start_time)}‚Äì${formatTime(booking.timeslot?.end_time)}${booking.subslot ? `\n–ö–æ–º–∞–Ω–¥–∞/–ª–æ–¥–∫–∞: ${booking.subslot.title}` : ''}\n\n–£—á–∞—Å—Ç–Ω–∏–∫–∏:\n${membersText}`;
  await ctx.editMessageText(text, { parse_mode: 'Markdown', ...Markup.inlineKeyboard(memberButtons) });

}

// –ú–µ–Ω—é —Å–æ—Å—Ç–æ—è–Ω–∏—è –∑–∞–ø–∏—Å–∏ –¥–ª—è –∞–¥–º–∏–Ω–∞
bot.action(/admin_booking_(\d+)/, async (ctx) => {
  await safeAnswerCbQuery(ctx);
  const bookingId = Number((ctx as any).match[1]);
  await sendAdminBookingMenu(ctx,bookingId)
});


